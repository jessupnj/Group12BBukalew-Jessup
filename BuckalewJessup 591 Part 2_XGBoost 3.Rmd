---
title: "BuckalewJessup 591 Part 2"
author: "Duke Buckalew"
date: "2025-10-28"
output:
  html_document:
    code_folding: show
    df_print: paged
    number_sections: yes
    theme: readable
    toc: yes
    toc_float: yes
    code_download: yes
  word_document:
    toc: no
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, message=FALSE,warning=FALSE)
knitr::opts_chunk$set(fig.width=8, fig.height=6)

if(require(pacman)==0)
   {install.packages("pacman")}
pacman::p_load(devtools,caret,cluster,dplyr,fastDummies,leaps,pacman,tidyverse,skimr,fastDummies,GGally,holdout_dataExplorer,ggrepel,ggthemes,dslabs,scatterplot3d, doParallel, rpart, rpart.plot, randomForest, xgboost, ROCR)

if (!require(mlba)) {
  library(devtools)
  install_github("gedeck/mlba/mlba", force=FALSE)
}
pacman::p_load(mlba,tidyverse)
```

```{r}
holdout_data = read_csv("/Users/dukeb/Desktop/Grad School/Data/holdout.csv")
train_data = read_rds("/Users/dukeb/Desktop/Grad School/Data/group12sectionb-Buckalew-Jessup_train2.rds")
```


# Holdout Preprocessing

Everything that was done to our training data needs to be done to our holdout data.

```{r}
holdout_data$issue_d = my(holdout_data$issue_d)
holdout_data$earliest_cr_line = my(holdout_data$earliest_cr_line)
holdout_data$last_credit_pull_d = my(holdout_data$last_credit_pull_d)
holdout_data = holdout_data %>%
  drop_na(last_credit_pull_d)
```

```{r}
skewed = holdout_data %>%
select(annual_inc, dti, mort_acc, open_acc, pub_rec, pub_rec_bankruptcies, revol_bal, revol_util, total_acc, acc_now_delinq, delinq_2yrs)
```

```{r}
holdout_data$dti[holdout_data$dti==9999] <- NA
holdout_data$dti[holdout_data$dti == 380.53] <- NA
```

```{r}
holdout_data <- holdout_data %>%
  mutate(across(annual_inc, log1p))
```

```{r}
holdout_data$mort_acc[is.na(holdout_data$mort_acc)] <- 0
holdout_data <- holdout_data %>%
  mutate(MortAccBin = case_when(
    mort_acc == 0 ~ "0",
    mort_acc == 1 ~ "1",
    mort_acc <= 3 ~ "2-3",
    mort_acc <= 6 ~ "4-6",
    mort_acc <= 9 ~ "7-9",
    mort_acc >= 10 ~ "10+",
    TRUE ~ NA_character_
  ))
holdout_data$MortAccBin <- factor(holdout_data$MortAccBin, 
                       levels = c("0", "1", "2-3", "4-6", "7-9", "10+"))
holdout_data = holdout_data %>%
  select(-mort_acc)
```

```{r}
holdout_data <- holdout_data %>%
  mutate(AccNowDelinqBin = case_when(
    acc_now_delinq == 0 ~ "0",
    acc_now_delinq == 1 ~ "1",
    acc_now_delinq >= 2 ~ "2+",
    TRUE ~ NA_character_
  ))
holdout_data$AccNowDelinqBin <- factor(holdout_data$AccNowDelinqBin,
                               levels = c("0", "1", "2+"))
holdout_data = holdout_data %>%
  select(-acc_now_delinq)
```

```{r}
holdout_data <- holdout_data %>%
  mutate(Delinq2YearBin = case_when(
    delinq_2yrs == 0 ~ "0",
    delinq_2yrs == 1 ~ "1",
    delinq_2yrs == 2 ~ "2",
    delinq_2yrs == 3 ~ "3",
    delinq_2yrs == 4 ~ "4",
    delinq_2yrs == 5 ~ "5",
    delinq_2yrs == 6 ~ "6",
    delinq_2yrs == 7 ~ "7",
    delinq_2yrs == 8 ~ "8",
    delinq_2yrs == 9 ~ "9",
    delinq_2yrs >= 10 ~ "10+",
    TRUE ~ NA_character_
  ))
holdout_data$Delinq2YearBin <- factor(holdout_data$Delinq2YearBin,
                               levels = c("0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10+"))
holdout_data = holdout_data %>%
  select(-delinq_2yrs)
```

```{r}
holdout_data <- holdout_data %>%
  mutate(open_acc = pmin(open_acc, 32))
```

```{r}
holdout_data <- holdout_data %>%
  mutate(PubRecBin = case_when(
    pub_rec == 0 ~ "0",
    pub_rec == 1 ~ "1",
    pub_rec >= 2 ~ "2+",
    TRUE ~ NA_character_
  ))

holdout_data$PubRecBin <- factor(holdout_data$PubRecBin,
                               levels = c("0", "1", "2+"))

holdout_data = holdout_data %>%
  select(-pub_rec)
```

```{r}
holdout_data <- holdout_data %>%
  mutate(PubRecBankBin = case_when(
    pub_rec_bankruptcies == 0 ~ "0",
    pub_rec_bankruptcies == 1 ~ "1",
    pub_rec_bankruptcies >= 2 ~ "2+",
    TRUE ~ "Unknown"
  ))

holdout_data$PubRecBankBin <- factor(holdout_data$PubRecBankBin,
                               levels = c("0", "1", "2+", "Unknown"))

holdout_data = holdout_data %>%
  select(-pub_rec_bankruptcies)
```

```{r}
holdout_data <- holdout_data %>%
  mutate(across(revol_bal, log1p))
```

```{r}
holdout_data$revol_util[is.na(holdout_data$revol_util)] <- 0
holdout_data <- holdout_data %>%
  mutate(revol_util = pmin(revol_util, 150))
```

```{r}
holdout_data$loan_default = factor(holdout_data$loan_default,
                           levels = c("No", "Yes"),
                           labels = c("No", "Yes"))
```

```{r}
holdout_data$term = factor(holdout_data$term,
                  levels = c("36 months", "60 months"))
```

```{r}
holdout_data = holdout_data %>%
  select(-installment)
```

```{r}
holdout_data$grade = factor(holdout_data$grade,
                    levels = c("A", "B", "C", "D", "E", "F", "G"))
```

```{r}
holdout_data$sub_grade = factor(holdout_data$sub_grade,
                    levels = c("A1", "A2", "A3", "A4", "A5", "B1", "B2", "B3", "B4", "B5", "C1", "C2", "C3", "C4", "C5", "D1", "D2", "D3", "D4", "D5", "E1", "E2", "E3", "E4", "E5", "F1", "F2", "F3", "F4", "F5", "G1", "G2", "G3", "G4", "G5"))
```

```{r}
library(dplyr)
library(stringr)

abbr = c(
  "\\bsr\\b"="senior","\\bjr\\b"="junior","\\bmgr\\b"="manager","\\bdir\\b"="director",
  "\\bvp\\b"="vice president","\\bits?\\b"="it","\\bdev\\b"="developer","\\beng\\b"="engineer",
  "\\brn\\b"="registered nurse","\\bqa\\b"="quality assurance",
  "\\bcfo\\b"="chief financial officer","\\bceo\\b"="chief executive officer","\\bcoo\\b"="chief operating officer")
filler = "\\b(the|a|an|of|for|with|and|at|in|to|dept|department|company|llc|inc|co|corp|plc|gmbh|ltd|hospital|university|school)\\b"

fingerprint = function(clean) clean %>%
  str_to_lower() %>%
  str_replace_all("[[:punct:]]"," ") %>%
  str_squish() %>%
  str_replace_all(abbr) %>%
  str_replace_all(filler," ") %>%
  str_squish() %>%
  (function(sort) sapply(str_split(sort,"\\s+"), function(word) paste(sort(word), collapse=" ")))()

holdout_data = holdout_data %>%
  mutate(
    emp_title = na_if(trimws(emp_title), "Other"),           
    emp_title_norm = fingerprint(emp_title),           
    emp_title_norm = na_if(emp_title_norm, "Other")         
  )

holdout_data = holdout_data %>%
  mutate(
    emp_role = case_when(
      str_detect(emp_title_norm, "\\bmanager\\b")                       ~ "manager",
      str_detect(emp_title_norm, "\\bdirector\\b")                      ~ "director",
      str_detect(emp_title_norm, "\\bvice president\\b|\\bvp\\b")       ~ "vice president",
      str_detect(emp_title_norm, "\\bchief executive officer\\b")       ~ "ceo",
      str_detect(emp_title_norm, "\\bchief financial officer\\b")       ~ "cfo",
      str_detect(emp_title_norm, "\\bchief operating officer\\b")       ~ "coo",
      str_detect(emp_title_norm, "\\bregistered nurse\\b|\\bnurse\\b")  ~ "nurse",
      str_detect(emp_title_norm, "\\bengineer\\b|\\bdeveloper\\b|\\bdev\\b") ~ "engineer",
      str_detect(emp_title_norm, "\\banalyst\\b")                       ~ "analyst",
      str_detect(emp_title_norm, "\\baccountant\\b|\\baccounting\\b")   ~ "accountant",
      str_detect(emp_title_norm, "\\bsales\\b|\\bsalesperson\\b")       ~ "sales",
      str_detect(emp_title_norm, "\\btechnician\\b|\\btech\\b")         ~ "technician",
      str_detect(emp_title_norm, "\\bteacher\\b|\\beducator\\b")        ~ "teacher",
      str_detect(emp_title_norm, "\\bassistant\\b|\\badmin\\b")         ~ "assistant/admin",
      str_detect(emp_title_norm, "\\bdriver\\b")                        ~ "driver",
      str_detect(emp_title_norm, "\\bowner\\b|\\bfounder\\b")           ~ "owner/founder",
      str_detect(emp_title_norm, "\\bcustomer service\\b|\\bcsr\\b")    ~ "customer service",
      is.na(emp_title_norm)                                             ~ "Unknown",
      TRUE                                                              ~ emp_title_norm))

top_titles = count(holdout_data, emp_title_norm, sort = TRUE) %>% slice_head(n = 500) %>% pull(emp_title_norm)

holdout_data = holdout_data %>%
  mutate(
    emp_title_clean = if_else(emp_title_norm %in% top_titles, emp_title_norm, "Other")
  )
freq = count(holdout_data, emp_title_clean, sort = TRUE)

holdout_data = holdout_data %>%
  select(-emp_title, -emp_role, -emp_title_norm)
```

This will later be dropped due to its high degree of "Other"'s, as well as the fact that it's predictive power is most likely minimal.

```{r}
holdout_data <- holdout_data %>%
  mutate(emp_length = case_when(
    emp_length == 0 ~ "< 1 year",
    emp_length == 1 ~ "1 year",
    emp_length == 2 ~ "2 years",
    emp_length == 3 ~ "3 years",
    emp_length == 4 ~ "4 years",
    emp_length == 5 ~ "5 years",
    emp_length == 6 ~ "6 years",
    emp_length == 7 ~ "7 years",
    emp_length == 8 ~ "8 years",
    emp_length == 9 ~ "9 years",
    emp_length >= 10 ~"10+ years",
    TRUE ~ "NA"
  ))

holdout_data$emp_length <- factor(holdout_data$emp_length,
                               levels = c("< 1 year", "1 year", "2 years", "3 years", "4 years", "5 years", "6 years", "7 years", "8 years", "9 years", "10+ years", "NA"))
```

```{r}
holdout_data$home_ownership = factor(holdout_data$home_ownership,
                             levels = c("MORTGAGE", "NONE", "OTHER", "OWN", "RENT"))
```

```{r}
holdout_data$verification_status = factor(holdout_data$verification_status,
                                  levels = c("Not Verified", "Source Verified", "Verified"))
```

```{r}
holdout_data$purpose = factor(holdout_data$purpose,
                      levels = c("car", "credit_card", "debt_consolidation", "educational",                               "home_improvement", "house", "major_purchase", "medical", "moving", "other",                        "renewable_energy", "small_business", "vacation", "wedding"))
```

```{r}
holdout_data = holdout_data %>%
  select(-title)
```

```{r}
holdout_data$initial_list_status = factor(holdout_data$initial_list_status,
                                  levels = c("f", "w"))
```

```{r}
holdout_data$application_type = factor(holdout_data$application_type,
                               levels = c("DIRECT_PAY", "INDIVIDUAL", "JOINT"))
```

```{r}
library(dplyr)
library(tidyr)
library(stringr)

holdout_data = holdout_data %>%
  separate(address, into = c("street", "rest"), sep = "\\r\\n", remove = FALSE) %>%
  separate(rest, into = c("city", "state_zip"), sep = ",", remove = TRUE) %>%
  mutate(state_zip = str_squish(state_zip)) %>%
  separate(state_zip, into = c("state", "zip"), sep = " ", extra = "merge")
holdout_data = holdout_data %>%
  select(-c(address, zip, state, street, city))
```

We decided to drop these as well since their predictive power is most likely minimal.

```{r}
holdout_data = holdout_data %>%
  mutate(fico_score = (holdout_data$fico_range_high + holdout_data$fico_range_low) / 2)
holdout_data = holdout_data %>%
  select(-fico_range_low, -fico_range_high)
```

```{r}
holdout_data <- holdout_data %>%
  mutate(mths_since_last_delinq = pmin(mths_since_last_delinq, 86))

holdout_data <- holdout_data %>%
  mutate(mths_since_last_delinq = case_when(
    mths_since_last_delinq <= 10 ~ "<=10",
    mths_since_last_delinq <= 20 ~ "11-20",
    mths_since_last_delinq <= 30 ~ "21-30",
    mths_since_last_delinq <= 40 ~ "31-40",
    mths_since_last_delinq <= 50 ~ "41-50",
    mths_since_last_delinq <= 60 ~ "51-60",
    mths_since_last_delinq <= 70 ~ "61-70",
    mths_since_last_delinq <= 86 ~ "71+",
    mths_since_last_delinq > 86 ~ "Never",
    TRUE ~ "Never"
  ))

holdout_data$mths_since_last_delinq <- factor(holdout_data$mths_since_last_delinq,
                               levels = c("<=10", "11-20", "21-30", "31-40", "41-50", "51-60", "61-70", "71+", "Never"))
```

```{r}
holdout_data = holdout_data %>%
  select(-hardship_flag)

```

```{r}
holdout_data$debt_settlement_flag = factor(holdout_data$debt_settlement_flag,
                               levels = c("N", "Y"))
```

```{r}
holdout_data = holdout_data %>%
  drop_na(home_ownership)
train_data = train_data %>%
  drop_na(dti)
```

Dropping the very few remaining NAs we have.

# Making a Balanced Training Set
```{r}
majority <- train_data %>% filter(loan_default == "No")
minority <- train_data %>% filter(loan_default == "Yes")

# undersample majority to match minority count
majority_down <- majority %>%
  sample_n(nrow(minority))

# combine back
train_balanced <- bind_rows(minority, majority_down) %>%
  sample_frac(1)  # shuffle rows

table(train_balanced$loan_default)
```

Here we make a balanced training set to train our boosted model. We originally used our training data with all of the observations, but our model was so extensive that both of our computers would run out of memory before completing the model. Reducing our observations to ensure a balanced model not only solved this problem but also had the added benefit of potentially increasing the model performance. 

```{r}
holdout_data = holdout_data %>%
  select(-emp_title_clean)
train_balanced = train_balanced %>%
  select(-emp_title_clean)
```

Dropping emp_title_clean like mentioned above.

# Making the best Boosted Model
```{r}
set.seed(123)

best_tune = expand.grid(
  nrounds = 150,
  max_depth = 5,
  eta = 0.3,
  gamma = 0,
  colsample_bytree = 0.8,
  min_child_weight = 1,
  subsample = 1
)

cores= 6
cl <- parallel::makeCluster(cores)  
registerDoParallel(cl)
cv_control <- trainControl(
  method = "cv",
  number = 5,
  allowParallel = TRUE,
  classProbs = TRUE,
  summaryFunction = twoClassSummary
)
xgb_model <- train(
  loan_default ~ ., 
  data = train_balanced,
  method = "xgbTree",
  trControl = cv_control,  
  tuneGrid = best_tune,
  nthread = 1,
  metric = "ROC"
)
stopCluster(cl) 
registerDoSEQ()
```

We originally ran this with a tuneLength of 5 in order to find the best tuned model with regards to AUC. In order to increase efficiency and decrease the computing power necessary to run this, we have replaced tuneLength with the parameters mentioned in our tuneGrid, which is the best model.

# Getting Model Metrics
```{r}
pred.holdout=data.frame(loan_default=holdout_data$loan_default) 
pred.holdout$xgb.class <- predict(xgb_model,
                                  holdout_data,
                                  type ="raw"
                                      )
pred.holdout$xgb.prob <- predict(xgb_model,
                                  holdout_data,
                                  type ="prob"
                                      )[,"Yes"]
pred_boost=prediction(pred.holdout$xgb.prob, pred.holdout$loan_default)
perf_boost=performance(pred_boost, "tpr", "fpr")
```

```{r}
truth <- pred.holdout$loan_default

# Get model names based on .prob columns
model_names <- names(pred.holdout) %>%
  stringr::str_subset("\\.prob$") %>%
  stringr::str_remove("\\.prob$")

# Function to compute metrics for each model
get_metrics <- function(model_name) {
  prob_col <- paste0(model_name, ".prob")
  class_col <- paste0(model_name, ".class")

  # Extract predictions
  prob <- pred.holdout[[prob_col]]
  pred <- factor(pred.holdout[[class_col]], levels = c("No", "Yes"))

  # Confusion matrix
  cm <- caret::confusionMatrix(pred, truth, positive = "Yes")

  # AUC
  roc_obj <- pROC::roc(truth, prob, quiet = TRUE)

  # Metrics
  data.frame(
    Model = model_name,
    Accuracy = cm$overall["Accuracy"],
    Sensitivity = cm$byClass["Sensitivity"],
    Specificity = cm$byClass["Specificity"],
    F1 = MLmetrics::F1_Score(
      y_pred = pred,
      y_true = truth,
      positive = "Yes"
    ),
    AUC = as.numeric(roc_obj$auc)
  )
}
get_metrics("xgb")
```

Our boosted model is relatively successful, with an F1 score of .71 and an AUC score of .92. Since we trained our model to find the best AUC, it would make sense that this is the highest metric in our function. Overall we are satisfied with this model, and are looking forward to seeing how it performs with our other models.

```{r}
roc_boost_auc <- ROCR::performance(pred_boost, "auc")
roc_boost_auc <-roc_boost_auc@y.values[[1]]
print(paste("Boosted Model: ",roc_boost_auc))
```

# Graphing ROC Curve
```{r}
# Plot ROC curves
plot(perf_boost, col="steelblue", lwd=2, main="ROC Curves for Decision Trees")
legend("bottomright", 
       legend=c("BestTuned Boosted Tree"), 
       col="steelblue", lwd=2)
abline(a = 0, b = 1, col = "tomato", lty = 2, lwd = 2)
# Add AUC values to the plot
```

This graph shows our model performs much better than random chance. 

# Saving Model Results
```{r}
saveRDS(pred.holdout, "pred.holdout.rds")
saveRDS(xgb_model, "xgb_model_best.rds")
```

Saving our model so there is no need to carry over our code to our other MarkDown files.